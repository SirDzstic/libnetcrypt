/* 
 * libnetcrypt -- Encrypted communication with DH and AES
 * 
 * Copyright (C) 2013-2014  Martin Wolters
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to 
 * the Free Software Foundation, Inc.
 * 51 Franklin Street, Fifth Floor
 * Boston, MA  02110-1301, USA
 * 
 */

#include <stdlib.h>
#include <string.h>

#include "../shared/mem.h"
#include "lnc.h"

#ifdef WITH_AUTH

static const uint8_t b32_table[33] = {
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
    'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', '2', '3', '4', '5', '6', '7', '='
};

static const uint8_t inv_b32_table[256] = {
        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xe0, 0xe0, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0x20, 0xe0, 0xe0,
        0xe0, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
        0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0
};

static size_t getbits(const uint8_t *in, const size_t insize, const size_t offs) {
    size_t start = offs / 8;
    size_t shift = offs % 8;
    size_t out;

    if(start > insize - 1)
        return 32;

    out = (in[start] & (0xff >> shift));

    if(shift >= 3) {
        out <<= shift - 3;
        shift = ((offs + 5) % 8);
        out |= in[start + 1] >> (8 - shift);
    } else
        out >>= 3 - shift;

    return out;
}

int lnc_b32_enc(const uint8_t *in, const size_t insize, uint8_t **out) {
    size_t pos = 0;
    size_t index, padsize, outsize;

    padsize = insize + ((insize % 5) ? (5 - (insize % 5)) : 0);
    outsize = ((padsize * 8) / 5) + 1;

    if((*out = malloc(outsize)) == NULL) {
        return LNC_ERR_MALLOC;
    }

    do {
        index = getbits(in, insize, pos * 5);
        (*out)[pos++] = b32_table[index];
    } while(pos < outsize);

    (*out)[outsize - 1] = '\0';
    return LNC_OK;
}

int lnc_b32_dec(const uint8_t *in, uint8_t **out, size_t *outsize) {
    size_t insize = strlen(in);
    size_t i, shift = 0, pos = 0;
    uint8_t decbyte, mask;

	*outsize = insize * 5 / 8;

    if((*out = malloc(*outsize)) == NULL) {
        *outsize = 0;
        return LNC_ERR_MALLOC;
    }

    memset(*out, 0, *outsize);

    for(i = 0; i < insize; i++) {
        if(in[i] == '=' || in[i] == '0')
            break;

        decbyte = inv_b32_table[in[i]];
        if(decbyte == 0xe0) {
			*outsize = 0;
			free(*out);
			return LNC_ERR_VAL;
		}

        if(shift <= 3) {
            (*out)[pos] |= (decbyte << (3 - shift));
        } else {
            mask = 0xff >> (11 - shift);
            (*out)[pos++] |= (decbyte >> (shift - 3));
            (*out)[pos] |= (decbyte & mask) << (11 - shift);
        }
        shift = (shift + 5) % 8;
        if(!shift)
            pos++;
    }

    return LNC_OK;
}

#endif